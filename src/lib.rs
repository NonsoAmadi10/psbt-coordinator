//! Core library for PSBT Coordinator
//!
//! This module provides shared types and utilities for the 2-of-3 multisig
//! PSBT workflow. The key insight is SEPARATION OF CONCERNS:
//!
//! - Coordinator: Knows all xpubs, creates PSBTs, combines signatures
//! - Signers: Know only their own xprv, add partial signatures
//!
//! Neither role alone can spend funds. This is the security model.

use bitcoin::bip32::{DerivationPath, Fingerprint, Xpub};
use bitcoin::hashes::Hash;
use bitcoin::secp256k1::{PublicKey, Secp256k1};
use bitcoin::{Address, Network, ScriptBuf, WitnessProgram, WitnessVersion};
use miniscript::descriptor::{Descriptor, DescriptorPublicKey};
use serde::{Deserialize, Serialize};
use std::str::FromStr;

/// Key data loaded from JSON files (generated by keygen)
/// 
/// In production:
/// - xprv stays on the signing device (HSM, hardware wallet, air-gapped computer)
/// - Only xpub and fingerprint are shared with the Coordinator
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyData {
    pub name: String,
    pub xprv: String,
    pub xpub: String,
    pub fingerprint: String,
    pub derivation_path: String,
}

/// Wallet configuration for 2-of-3 multisig
/// 
/// This is what the Coordinator knows about the wallet.
/// Notice: NO private keys here!
#[derive(Debug, Clone)]
pub struct MultisigWallet {
    /// The parsed output descriptor
    pub descriptor: Descriptor<DescriptorPublicKey>,
    /// Network (regtest/testnet/mainnet)
    pub network: Network,
    /// Number of signatures required (M in M-of-N)
    pub threshold: usize,
    /// The 3 xpubs with their origin info
    pub xpub_origins: Vec<XpubOrigin>,
}

/// Extended public key with its derivation origin
/// 
/// Origin info is critical for PSBTs:
/// - fingerprint: identifies which master key
/// - path: how to derive from master to this xpub
#[derive(Debug, Clone)]
pub struct XpubOrigin {
    pub xpub: Xpub,
    pub fingerprint: Fingerprint,
    pub derivation_path: DerivationPath,
}

impl MultisigWallet {
    /// Create a new 2-of-3 multisig wallet from 3 key files
    ///
    /// # Security Note
    /// This function only reads xpubs, never xprvs.
    /// The Coordinator should never have access to private keys.
    pub fn from_key_files(key_paths: &[&str], network: Network) -> Result<Self, Box<dyn std::error::Error>> {
        if key_paths.len() != 3 {
            return Err("Expected exactly 3 key files for 2-of-3 multisig".into());
        }

        let mut xpub_origins = Vec::new();
        let mut descriptor_parts = Vec::new();

        for path in key_paths {
            let key_data: KeyData = serde_json::from_str(&std::fs::read_to_string(path)?)?;
            
            let xpub = Xpub::from_str(&key_data.xpub)?;
            let fingerprint = Fingerprint::from_str(&key_data.fingerprint)?;
            let derivation_path = DerivationPath::from_str(&key_data.derivation_path)?;

            xpub_origins.push(XpubOrigin {
                xpub,
                fingerprint,
                derivation_path,
            });

            // Build descriptor string component
            // Format: [fingerprint/path]xpub
            descriptor_parts.push(format!(
                "[{}/{}]{}",
                key_data.fingerprint,
                // Remove 'm/' prefix for descriptor format
                key_data.derivation_path.strip_prefix("m/").unwrap_or(&key_data.derivation_path),
                key_data.xpub
            ));
        }

        // Build the full descriptor string
        // wsh(sortedmulti(2, key1, key2, key3))
        let descriptor_string = format!(
            "wsh(sortedmulti(2,{},{},{}))",
            descriptor_parts[0],
            descriptor_parts[1],
            descriptor_parts[2]
        );

        let descriptor = Descriptor::<DescriptorPublicKey>::from_str(&descriptor_string)?;

        Ok(Self {
            descriptor,
            network,
            threshold: 2,
            xpub_origins,
        })
    }

    /// Derive an address at the given index
    ///
    /// # Arguments
    /// * `index` - Address index (0, 1, 2, ...)
    /// * `is_change` - If true, use change derivation (internal chain)
    ///
    /// # Returns
    /// The derived P2WSH address
    pub fn derive_address(&self, index: u32, is_change: bool) -> Result<Address, Box<dyn std::error::Error>> {
        let secp = Secp256k1::new();
        
        // Derive the concrete descriptor at this index
        let derived = self.descriptor
            .at_derivation_index(index)?;
        
        // Get the script pubkey
        let script_pubkey = derived.script_pubkey();
        
        // Convert to address
        let address = Address::from_script(&script_pubkey, self.network)?;
        
        Ok(address)
    }

    /// Get the witness script for the given address index
    ///
    /// This is the actual multisig script that goes in the witness:
    /// OP_2 <pubkey_a> <pubkey_b> <pubkey_c> OP_3 OP_CHECKMULTISIG
    ///
    /// For P2WSH, this script is hashed to create the address.
    pub fn witness_script(&self, index: u32) -> Result<ScriptBuf, Box<dyn std::error::Error>> {
        let derived = self.descriptor
            .at_derivation_index(index)?;
        
        // For wsh() descriptors, we need the inner script
        if let Descriptor::Wsh(wsh) = derived {
            Ok(wsh.inner_script())
        } else {
            Err("Expected WSH descriptor".into())
        }
    }
    
    /// Get public keys for the given address index, sorted as they appear in the script
    pub fn get_pubkeys(&self, index: u32) -> Result<Vec<PublicKey>, Box<dyn std::error::Error>> {
        let secp = Secp256k1::new();
        
        // Get the derived descriptor
        let derived = self.descriptor.at_derivation_index(index)?;
        
        // Extract public keys from the descriptor
        let mut pubkeys = Vec::new();
        
        // For each origin, derive the child public key
        for origin in &self.xpub_origins {
            // Derive child at index (non-hardened)
            let child_path = DerivationPath::from_str(&format!("m/{}", index))?;
            let child_xpub = origin.xpub.derive_pub(&secp, &child_path)?;
            pubkeys.push(child_xpub.public_key);
        }
        
        // sortedmulti sorts by public key bytes
        pubkeys.sort_by(|a, b| a.serialize().cmp(&b.serialize()));
        
        Ok(pubkeys)
    }

    /// Get the descriptor string representation
    pub fn descriptor_string(&self) -> String {
        self.descriptor.to_string()
    }
}

/// Print a nice summary of the wallet configuration
pub fn print_wallet_summary(wallet: &MultisigWallet) {
    println!("═══════════════════════════════════════════════════════════════");
    println!("                    2-of-3 MULTISIG WALLET                      ");
    println!("═══════════════════════════════════════════════════════════════");
    println!();
    println!("Network: {:?}", wallet.network);
    println!("Threshold: {} of {}", wallet.threshold, wallet.xpub_origins.len());
    println!();
    println!("Signers:");
    for (i, origin) in wallet.xpub_origins.iter().enumerate() {
        let xpub_short = &origin.xpub.to_string()[..20];
        println!("  {}. [{}] {}...", i + 1, origin.fingerprint, xpub_short);
        println!("     Path: {}", origin.derivation_path);
    }
    println!();
    println!("Descriptor:");
    println!("  {}", wallet.descriptor);
    println!();
    
    // Derive first 3 addresses
    println!("First 3 Addresses:");
    for i in 0..3 {
        match wallet.derive_address(i, false) {
            Ok(addr) => println!("  [{}] {}", i, addr),
            Err(e) => println!("  [{}] Error: {}", i, e),
        }
    }
    println!();
    println!("═══════════════════════════════════════════════════════════════");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_wallet_creation() {
        // This test would require actual key files
        // In a real test, we'd create temporary key files
    }
}
